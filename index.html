<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>iOS Watermark Tool</title>
    <style>
        /* iOS-optimized styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 10px;
            -webkit-text-size-adjust: 100%;
            touch-action: manipulation;
        }
        .container {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 100%;
            box-sizing: border-box;
        }
        
        /* iOS-friendly touch targets */
        button, .radio-option, input[type="range"] {
            min-height: 44px; /* Apple's recommended minimum */
        }
        #colorBtn {
            min-width: 44px;
            padding: 0 15px;
        }
        
        /* Enhanced color display */
        .color-display {
            width: 44px;
            height: 44px;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        
        /* Improved slider appearance */
        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            margin: 15px 0;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #007AFF;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        /* Preview area */
        #previewContainer {
            border: 2px solid #ddd;
            min-height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 15px 0;
            background-color: white;
            position: relative;
            border-radius: 10px;
            aspect-ratio: 4/3;
        }
        
        /* Loading indicator */
        #loadingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border-radius: 8px;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007AFF;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-top: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Watermark Tool</h1>
        
        <div id="previewContainer">
            <div id="loadingOverlay">
                <div id="loadingMessage">Processing...</div>
                <div class="loader"></div>
            </div>
            <button id="prevBtn" class="nav-arrow">←</button>
            <div id="previewText">Select images to begin</div>
            <img id="previewImage" style="display: none;">
            <button id="nextBtn" class="nav-arrow">→</button>
        </div>
        
        <div id="controls-section">
            <button id="chooseImagesBtn">Choose Images</button>
            <div id="imagesInfo">No images selected</div>
            
            <div class="radio-group">
                <div class="radio-option selected" data-value="black">Black</div>
                <div class="radio-option" data-value="gold">Gold</div>
                <div class="radio-option" data-value="white">White</div>
            </div>
            
            <div class="logo-opacity-strong">
                <div class="slider-container">
                    <label for="opacitySlider">Logo Opacity:</label>
                    <input type="range" id="opacitySlider" min="0" max="100" value="80">
                    <span id="opacityValue" class="slider-value">80</span><span>%</span>
                </div>
                
                <div class="slider-container">
                    <label for="coverageSlider">Logo Size:</label>
                    <input type="range" id="coverageSlider" min="5" max="100" value="25">
                    <span id="coverageValue" class="slider-value">25</span><span>%</span>
                </div>
                
                <div class="option-group">
                    <div class="option">
                        <label>Position:</label>
                        <select id="positionSelect">
                            <option value="right">Right</option>
                            <option value="left">Left</option>
                            <option value="center">Center</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="shadow-controls">
                <div class="option-group">
                    <div class="option">
                        <label>Top Shadow</label>
                        <input type="checkbox" id="shadowTop">
                    </div>
                    <div class="option">
                        <label>Bottom Shadow</label>
                        <input type="checkbox" id="shadowBottom" checked>
                    </div>
                </div>
                
                <div class="slider-container">
                    <label for="shadowOpacitySlider">Shadow Opacity:</label>
                    <input type="range" id="shadowOpacitySlider" min="0" max="100" value="50">
                    <span id="shadowOpacityValue" class="slider-value">50</span><span>%</span>
                </div>
                
                <div class="slider-container">
                    <label for="shadowStrengthSlider">Shadow Strength:</label>
                    <input type="range" id="shadowStrengthSlider" min="1" max="100" value="25">
                    <span id="shadowStrengthValue" class="slider-value">25</span><span>%</span>
                </div>
                
                <div class="option-group">
                    <label>Shadow Color:</label>
                    <div id="colorDisplay" class="color-display"></div>
                    <button id="colorBtn">Choose</button>
                </div>
            </div>
            
            <button id="exportBtn">Export All</button>
        </div>
        
        <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
    </div>

    <script>
        // Configuration
        const logoUrls = {
            black: "https://raw.githubusercontent.com/saintpann/watermark-logos/e83b24804159479cfd7bf63622cf38801754b33e/black.png",
            gold: "https://raw.githubusercontent.com/saintpann/watermark-logos/e83b24804159479cfd7bf63622cf38801754b33e/gold.png",
            white: "https://raw.githubusercontent.com/saintpann/watermark-logos/e83b24804159479cfd7bf63622cf38801754b33e/white.png"
        };

        // State
        let selectedImages = [];
        let currentImageIndex = 0;
        let logoType = "black";
        let shadowTop = false;
        let shadowBottom = true;
        let logoOpacity = 80;
        let coverage = 25;
        let shadowOpacity = 50;
        let shadowStrength = 25;
        let shadowColor = { r: 0, g: 0, b: 0 };
        let logoImages = {};
        let logoPosition = "right";

        // DOM Elements
        const chooseImagesBtn = document.getElementById('chooseImagesBtn');
        const imagesInfo = document.getElementById('imagesInfo');
        const previewContainer = document.getElementById('previewContainer');
        const previewText = document.getElementById('previewText');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const previewImage = document.getElementById('previewImage');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const fileInput = document.getElementById('fileInput');
        const radioOptions = document.querySelectorAll('.radio-option');
        const shadowTopCheckbox = document.getElementById('shadowTop');
        const shadowBottomCheckbox = document.getElementById('shadowBottom');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValue = document.getElementById('opacityValue');
        const coverageSlider = document.getElementById('coverageSlider');
        const coverageValue = document.getElementById('coverageValue');
        const positionSelect = document.getElementById('positionSelect');
        const shadowOpacitySlider = document.getElementById('shadowOpacitySlider');
        const shadowOpacityValue = document.getElementById('shadowOpacityValue');
        const shadowStrengthSlider = document.getElementById('shadowStrengthSlider');
        const shadowStrengthValue = document.getElementById('shadowStrengthValue');
        const colorDisplay = document.getElementById('colorDisplay');
        const colorBtn = document.getElementById('colorBtn');
        const exportBtn = document.getElementById('exportBtn');

        // Image loading with iOS error handling
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                
                const timeout = setTimeout(() => {
                    reject(new Error('Image load timed out'));
                }, 15000); // Longer timeout for mobile
                
                img.onload = () => {
                    clearTimeout(timeout);
                    // Fix iOS image orientation
                    if (typeof EXIF !== 'undefined' && url instanceof File) {
                        EXIF.getData(img, function() {
                            const orientation = EXIF.getTag(this, 'Orientation');
                            if (orientation && orientation !== 1) {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                
                                // Apply orientation correction
                                switch(orientation) {
                                    case 3:
                                        ctx.rotate(Math.PI);
                                        ctx.drawImage(img, -img.width, -img.height);
                                        break;
                                    case 6:
                                        canvas.width = img.height;
                                        canvas.height = img.width;
                                        ctx.rotate(Math.PI/2);
                                        ctx.drawImage(img, 0, -img.height);
                                        break;
                                    case 8:
                                        canvas.width = img.height;
                                        canvas.height = img.width;
                                        ctx.rotate(3*Math.PI/2);
                                        ctx.drawImage(img, -img.width, 0);
                                        break;
                                    default:
                                        ctx.drawImage(img, 0, 0);
                                }
                                
                                const correctedImg = new Image();
                                correctedImg.src = canvas.toDataURL('image/jpeg');
                                correctedImg.onload = () => resolve(correctedImg);
                                return;
                            }
                            resolve(img);
                        });
                    } else {
                        resolve(img);
                    }
                };
                
                img.onerror = () => {
                    clearTimeout(timeout);
                    reject(new Error('Failed to load image'));
                };
                
                if (url instanceof File) {
                    const reader = new FileReader();
                    reader.onload = (e) => img.src = e.target.result;
                    reader.readAsDataURL(url);
                } else {
                    img.src = url;
                }
            });
        }

        // Load logos with retry logic
        async function loadLogoImages() {
            showLoading("Loading logos...");
            try {
                const loadWithRetry = async (url, retries = 3) => {
                    for (let i = 0; i < retries; i++) {
                        try {
                            return await loadImage(url);
                        } catch (err) {
                            if (i === retries - 1) throw err;
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }
                };
                
                const [blackLogo, goldLogo, whiteLogo] = await Promise.all([
                    loadWithRetry(logoUrls.black),
                    loadWithRetry(logoUrls.gold),
                    loadWithRetry(logoUrls.white)
                ]);
                
                logoImages = {
                    black: blackLogo,
                    gold: goldLogo,
                    white: whiteLogo
                };
                hideLoading();
            } catch (error) {
                console.error("Error loading logos:", error);
                showLoading(`Error: ${error.message}`);
                createFallbackLogos();
            }
        }

        // Fallback logos
        function createFallbackLogos() {
            const createLogo = (color) => {
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 200;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = color;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('WATERMARK', 100, 100);
                const img = new Image();
                img.src = canvas.toDataURL();
                return img;
            };
            
            logoImages = {
                black: createLogo('black'),
                gold: createLogo('gold'),
                white: createLogo('white')
            };
            hideLoading();
        }

        // iOS-optimized color picker
        function chooseShadowColor() {
            const colorPicker = document.createElement('input');
            colorPicker.type = 'color';
            colorPicker.value = rgbToHex(shadowColor.r, shadowColor.g, shadowColor.b);
            
            // iOS-friendly events
            colorPicker.addEventListener('change', () => {
                const hex = colorPicker.value;
                const rgb = hexToRgb(hex);
                shadowColor = rgb;
                colorDisplay.style.backgroundColor = hex;
                updatePreview();
            });
            
            // Required for iOS to show picker
            colorPicker.click();
        }

        // iOS download helper
        function downloadImageIOS(src, filename) {
            // Create temporary link
            const link = document.createElement('a');
            link.href = src;
            link.download = filename;
            
            // iOS workaround
            if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
                const reader = new FileReader();
                fetch(src)
                    .then(res => res.blob())
                    .then(blob => {
                        reader.onload = () => {
                            const newTab = window.open();
                            newTab.document.write(
                                `<img src="${reader.result}" style="max-width: 100%;"/>`
                            );
                        };
                        reader.readAsDataURL(blob);
                    });
            } else {
                // Standard download for other devices
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        // Watermark application with independent opacity
        async function applyWatermark(image) {
            return new Promise((resolve) => {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = image.width;
                    canvas.height = image.height;
                    const ctx = canvas.getContext('2d');
                    
                    // 1. Draw original image
                    ctx.drawImage(image, 0, 0);
                    
                    // 2. Process shadows separately
                    if (shadowTop || shadowBottom) {
                        const shadowCanvas = document.createElement('canvas');
                        shadowCanvas.width = canvas.width;
                        shadowCanvas.height = canvas.height;
                        const shadowCtx = shadowCanvas.getContext('2d');
                        
                        if (shadowTop) applyTopShadow(shadowCtx);
                        if (shadowBottom) applyBottomShadow(shadowCtx);
                        
                        // Apply shadows with shadowOpacity only
                        ctx.globalAlpha = shadowOpacity / 100;
                        ctx.drawImage(shadowCanvas, 0, 0);
                        ctx.globalAlpha = 1.0;
                    }
                    
                    // 3. Process logo with its own opacity
                    addLogo(ctx, image);
                    
                    const result = new Image();
                    result.onload = () => resolve(result);
                    result.src = canvas.toDataURL('image/jpeg', 0.9);
                } catch (error) {
                    console.error("Watermark error:", error);
                    const result = new Image();
                    result.onload = () => resolve(result);
                    result.src = image.src;
                }
            });
        }

        // Shadow effects
        function applyTopShadow(ctx) {
            const shadowHeight = Math.floor(ctx.canvas.height * (shadowStrength / 100));
            for (let i = 0; i < shadowHeight; i++) {
                const alpha = Math.floor(shadowOpacity * (1 - i / shadowHeight));
                ctx.fillStyle = `rgba(${shadowColor.r}, ${shadowColor.g}, ${shadowColor.b}, ${alpha/255})`;
                ctx.fillRect(0, i, ctx.canvas.width, 1);
            }
        }

        function applyBottomShadow(ctx) {
            const shadowHeight = Math.floor(ctx.canvas.height * (shadowStrength / 100));
            const startY = ctx.canvas.height - shadowHeight;
            for (let i = 0; i < shadowHeight; i++) {
                const alpha = Math.floor(shadowOpacity * (i / shadowHeight));
                ctx.fillStyle = `rgba(${shadowColor.r}, ${shadowColor.g}, ${shadowColor.b}, ${alpha/255})`;
                ctx.fillRect(0, startY + i, ctx.canvas.width, 1);
            }
        }

        // Add logo with mobile sizing
        function addLogo(ctx, image) {
            const logo = logoImages[logoType];
            if (!logo) return;
            
            // Mobile-optimized sizing
            const isMobile = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            const sizeMultiplier = isMobile ? 0.7 : 0.5;
            const minDimension = Math.min(image.width, image.height);
            const logoSize = Math.floor(minDimension * (coverage / 100) * sizeMultiplier);
            
            const ratio = Math.min(logoSize / logo.width, logoSize / logo.height);
            const width = logo.width * ratio;
            const height = logo.height * ratio;
            
            let logoX, logoY;
            logoY = image.height - height - (isMobile ? 15 : 20);
            
            switch(logoPosition) {
                case "left": 
                    logoX = isMobile ? 10 : 20;
                    break;
                case "center": 
                    logoX = (image.width - width) / 2;
                    break;
                case "right": 
                default:
                    logoX = image.width - width - (isMobile ? 10 : 20);
            }
            
            // Apply logo opacity independently
            ctx.globalAlpha = logoOpacity / 100;
            ctx.drawImage(logo, logoX, logoY, width, height);
            ctx.globalAlpha = 1.0;
        }

        // Loading states
        function showLoading(message) {
            loadingMessage.textContent = message;
            loadingOverlay.style.display = 'flex';
        }

        function hideLoading() {
            loadingOverlay.style.display = 'none';
        }

        // Initialize
        async function init() {
            setupEventListeners();
            colorDisplay.style.backgroundColor = rgbToHex(shadowColor.r, shadowColor.g, shadowColor.b);
            await loadLogoImages();
        }

        // Event listeners
        function setupEventListeners() {
            chooseImagesBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            
            radioOptions.forEach(option => {
                option.addEventListener('click', () => {
                    radioOptions.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    logoType = option.dataset.value;
                    updatePreview();
                });
            });
            
            shadowTopCheckbox.addEventListener('change', () => {
                shadowTop = shadowTopCheckbox.checked;
                updatePreview();
            });
            
            shadowBottomCheckbox.addEventListener('change', () => {
                shadowBottom = shadowBottomCheckbox.checked;
                updatePreview();
            });
            
            opacitySlider.addEventListener('input', () => {
                logoOpacity = parseInt(opacitySlider.value);
                opacityValue.textContent = logoOpacity;
                updatePreview();
            });
            
            coverageSlider.addEventListener('input', () => {
                coverage = parseInt(coverageSlider.value);
                coverageValue.textContent = coverage;
                updatePreview();
            });
            
            positionSelect.addEventListener('change', (e) => {
                logoPosition = e.target.value;
                updatePreview();
            });
            
            shadowOpacitySlider.addEventListener('input', () => {
                shadowOpacity = parseInt(shadowOpacitySlider.value);
                shadowOpacityValue.textContent = shadowOpacity;
                updatePreview();
            });
            
            shadowStrengthSlider.addEventListener('input', () => {
                shadowStrength = parseInt(shadowStrengthSlider.value);
                shadowStrengthValue.textContent = shadowStrength;
                updatePreview();
            });
            
            colorBtn.addEventListener('click', chooseShadowColor);
            exportBtn.addEventListener('click', exportAll);
            
            prevBtn.addEventListener('click', showPreviousImage);
            nextBtn.addEventListener('click', showNextImage);
        }

        // File handling
        function handleFileSelect(e) {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                selectedImages = files;
                currentImageIndex = 0;
                updateImageCounter();
                updatePreview();
                updateNavButtons();
            }
        }

        // Navigation
        function showPreviousImage() {
            if (selectedImages.length > 0) {
                currentImageIndex = (currentImageIndex - 1 + selectedImages.length) % selectedImages.length;
                updateImageCounter();
                updatePreview();
            }
        }

        function showNextImage() {
            if (selectedImages.length > 0) {
                currentImageIndex = (currentImageIndex + 1) % selectedImages.length;
                updateImageCounter();
                updatePreview();
            }
        }

        function updateImageCounter() {
            imagesInfo.textContent = `${selectedImages.length} image${selectedImages.length !== 1 ? 's' : ''} selected (${currentImageIndex + 1}/${selectedImages.length})`;
        }

        function updateNavButtons() {
            if (selectedImages.length > 1) {
                prevBtn.style.display = 'block';
                nextBtn.style.display = 'block';
            } else {
                prevBtn.style.display = 'none';
                nextBtn.style.display = 'none';
            }
        }

        // Preview update
        async function updatePreview() {
            if (selectedImages.length === 0) {
                previewText.style.display = 'block';
                previewImage.style.display = 'none';
                hideLoading();
                previewText.textContent = "Select images to see preview";
                return;
            }
            
            try {
                showLoading("Processing image...");
                const file = selectedImages[currentImageIndex];
                
                const image = await loadImage(file);
                if (!logoImages[logoType]) throw new Error(`Logo type '${logoType}' not available`);
                
                const watermarked = await applyWatermark(image);
                
                previewText.style.display = 'none';
                previewImage.style.display = 'block';
                previewImage.src = watermarked.src;
                hideLoading();
            } catch (error) {
                console.error("Preview error:", error);
                hideLoading();
                previewText.style.display = 'block';
                previewImage.style.display = 'none';
                previewText.textContent = `Error: ${error.message}`;
            }
        }

        // Export with iOS handling
        async function exportAll() {
            if (selectedImages.length === 0) {
                alert("Please select images first.");
                return;
            }
            
            try {
                exportBtn.disabled = true;
                exportBtn.textContent = "Processing...";
                
                for (let i = 0; i < selectedImages.length; i++) {
                    const file = selectedImages[i];
                    exportBtn.textContent = `Processing ${i+1}/${selectedImages.length}...`;
                    
                    try {
                        const image = await loadImage(file);
                        const watermarked = await applyWatermark(image);
                        
                        const filename = file.name.replace(/(\.[\w\d_-]+)$/i, '_watermarked$1');
                        
                        // iOS-specific handling
                        if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                            const link = document.createElement('a');
                            link.href = watermarked.src;
                            link.download = filename;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            
                            // Additional iOS save prompt
                            if (window.webkit && window.webkit.messageHandlers) {
                                alert("Tap and hold the image, then select 'Save Image'");
                            }
                        } else {
                            downloadImageIOS(watermarked.src, filename);
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (error) {
                        console.error(`Error processing ${file.name}:`, error);
                    }
                }
                
                alert(`Processed ${selectedImages.length} images!`);
            } catch (error) {
                console.error("Export error:", error);
                alert("Export failed: " + error.message);
            } finally {
                exportBtn.disabled = false;
                exportBtn.textContent = "Export All";
            }
        }

        // Color helpers
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        // Start the app
        init();
    </script>
</body>
</html>